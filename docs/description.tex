\documentclass[12pt]{article}
%\documentclass[12pt]{report}
\usepackage{setspace}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{graphicx, amsmath}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{csquotes}
\usepackage{parskip}
\usepackage{hyperref}


\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Sharelatex Example},
    bookmarks=true,
    pdfpagemode=FullScreen,
}


%\setlength{\parindent}{1cm}
%\setlength{\parskip}{0.8cm}

%\doublespacing

%\author{Hunter Brooks}
%\title{Title}
\begin{document}
%\maketitle

%\begin{figure}
%\begin{centering}
	%top of pendulum with point mass
%	\includegraphics[width=1.0\textwidth]{/Users/hunterbrooks/Documents/SchoolDocuments/Fall2015/StarsAndGalaxies/papers/comp1/fig1.png}
%	\caption{Zoomed view of the six $M > 0.5 M\odot$ stars leaving the main sequence and becoming giants.  Note the origin of the black model, identical to our star.}
%	\end{centering}
%\end{figure}




\begin{titlepage}
	\centering
	{\scshape\LARGE Some Title \par}
	\vspace{4cm}
	%{\scshape\Large ASTRO 480, Spring 2016, Section 001\par Li, Yuexing \par}
	%\vspace{4cm}
	{\Large\itshape Sean Hunter Brooks\par}
	{\Large\itshape seanhunterbrooks@gmail.com\par}
	{\Large\itshape Git: @astronomerhunter\par}
	\vspace{9cm}
	%{Pennsylvania State University, University Park, PA\par}
	%{Department of Astronomy \& Astrophysics, Department of Physics\par}
	\vfill
% Bottom of the page
	{\large \today\par}
\end{titlepage}

\section*{Abstract}

\begin{quote}

This paper and accompanying code allows the reader to perform quantitative analysis of a basic graph theory problem, create custom solutions complete with visualizations, and easily apply techniques and concepts to other computer science domains.  The information is presented in such a way that little prior mathematical and coding knowledge is required.

\end{quote}

%\begin{multicols}{2}


\section{Introduction}

Imagine you're going on a road trip and you want to visit some number of cities while spending the shortest amount of time on the road.  Obviously some paths are more efficient than others; you'd want to avoid routes like New York to Los Angles to Boston and instead favor maybe NYC to Boston to LA.  But how does one find \textit{the} most efficient path?  Would you be willing to settle for a path that takes only slightly longer than the most efficient path?  This problem is historically described as the Traveling Salesmen Problem, or TSP, and is has been a computer science challenge since the 1930's.

The generalization of the TSP is prevalent in the world today. Package delivery, circuit board manufacturing, and product procurement in warehouses all involve our generalized path finding problem.  At the moment, mankind has only developed one reliable method to solve this general problem, but the drawbacks of the surefire method are extreme.  Because of this, many techniques have been developed to \textit{estimate} the optimal route.  These estimations can come very close to the optimal solution with relatively low repercussions of getting there.  The software in \href{https://github.com/astronomerhunter/pathfinding/tree/master}{this} Github repository offers the investigative reader the ability to learn about various predictive techniques.

This Github repository:
\begin{enumerate}
\item walks the reader through the details of the problem at hand
\item provides sample algorithms that can be used to solve the problem
\item allows the user to create custom algorithms to solve the problem
\item creations visualizations of the problem and solution
\end{enumerate}


Ultimately, this software and accompanying documentation was created with the following concepts in mind:
\begin{enumerate}
\item \textbf{Readability}.  Anyone with a brief introduction to Python should be able to interpret the code and with a college background in Mathematics one should be able to digest the documentation.
\item  \textbf{Education}.  Complex concepts are assemblies of simpler ones; learn as you go.  This package was created as an exercise in communication just as much as algorithm development.  Having said that, there are some phrases I may use that one may not recognize.  Use the Google.
\item  \textbf{Customizability}.  The software should facilitation integration of custom features as to fully empower the user to learn as much as possible.
\item \textbf{Generalization}.  By avoiding limitations in our explanations, we allow the reader to not learn about a niche computer science problem but instead apply the knowledge gained to as many of their endevors as possible.  You'll notice this repository doesn't include the phrase "Traveling Salesmen Probem".  
\end{enumerate}

To learn about the problem in detail, its best to provide a list of phrases used in this package and their documentation.



\section{Simple Vocabulary}

\begin{enumerate}

\item \textbf{The package}: The combination of documentation, code, and recommended external resources.

\item \textbf{The reader/The user}: You!

\item \textbf{Vertex}: A point of interest.  Since a vertex is a point, in the mathematical sense, it has some defining parameters.  A point on a map of the globe is normally said to have two defining parameters, longitude or latitude.  Likewise a point inside a ballon can be uniquely defined by its $X$-coordinate, $Y$-coordinate, and its $Z$-coordinate.  Because we desire generalization, we're going to call each point $p_n$ where $n$ is a counting number that denotes a unique identifier of that vertex.  For example, if I have a \textbf{Set of Vertices} containing three vertices, I could unique assign them each a name like $p_1$, $p_2$, and $p_3$.  Each point $p_n$  may have $m$ parameters which are described by $p_n^1$, $p_n^2$, ..., $p_n^m$.

\item \textbf{Path}: An ordered list of vertices.  Should you be solving the TSP with three vertices, A, B, and C, the paths [A, C, B] and [B, C, A] are valid.  The path [A, D, C, B] is not valid on the previously mentioned set of vertices because it includes D.  

\item \textbf{Optimal Path}: The most desired path among a set of vertices, according to the problem statement.

\item \textbf{Edge}: Connection between two vertices.  Each edge has a start vertex and an end vertex.

\item \textbf{Cost}:  The penalty for incorporating an edge in a path.  We don't restrict the domain of any costs, so zero and negative costs may exists.

\item \textbf{Cost Function}: a function $C$  that operates on inputs to provide a cost value.   Should the cost function be the cartesian distance in two dimensions, it would take a origin vertex and a destination vertex and maybe look like $C(p_{o}, p_{d}) = \sqrt{(p_{o}^1-p_{d}^1)^2 - (p_{o}^2-p_{d}^2)^2} $.  

\item \textbf{Optimal Cost}: the cost of the most desired path.

\end{enumerate}

With these in mind, we can define the problem statement.


\section{The Problem}

\begin{quote}

Given a set of $N$ vertices, each having $p_n^1$, $p_n^2$ where $0 \leq$ $p_n^1$, $p_n^2 \leq 1$, find the path with the lowest possible cost that contains each vertex at least once.  Calculate the cost between any two vertices as
$ C(p_{1}, p_{2}) = \sqrt{(p_{1}^1-p_{1}^1)^2 - (p_{2}^2-p_{2}^2)^2} $.

\end{quote}







This repository allows one to apply algorithms designed to quickly obtain the most desirable path.  Such algorithms are useless without a set of vertices to test them on, so the feature to create sets of vertices with various characteristics is included.  This codebase also makes it very easy to create and test user-created algorithms.  To learn more about the code, read `The Codebase` section.



\section{A Quantitative Description of the Problem}



The Codebase
Calculating the the minimum cost path through a set of notes is a computational taxing problem.  One must perform on the order of N! calculations to find the optimal path through a set of N vertices.  This becomes impractical on a standard Macbook when N > 10.  Estimating the optimal solution using intellegent algorithms is much more effective technique that normally results within 10% of the optimal solution with the most pragmatic algorithms.

This software package allows users to rapidly develop and test algorithms to estimate the optimal path.  With the code in this repository, one leverage the easy-to-use CLI to focus on the development of the interesting bits: the pathfinding algorithm itself.  Users of this codebase can:
1.  Create sets of vertices using `src/createmap.py`.  The placement of the vertices is based on some sort of 2D distriubtion.  A user can create their own distribution function or use any of the built in ones available at `src/mapcreation/*.py`.  A distribution function can take various other parameters, for example `fixednumberofgroups` requires the user to specify how many groups to create.  For examples of built in distribution functions, see `data/samplemaps/*.png`.  Currently the build in distribution functions are:
    1.  `randomuniform`: randomly distribute vertices
    1.  `ball`: a normal distribution in p<sub>1</sub> and p<sub>2</sub> centered at (0.5, 0.5)
    1.  `donut`: centers the peak of a normal distriubtion some distance away from (0.5, 0.5)
    1.  `fixednumberofgroups`: creates a handful of clusters randomly around the map
    1.  `sinusoidal`: the distriubtion function is sin<sup>2</sup>(p<sub>1</sub>, p<sub>2</sub>)
1.  Calculate a path through the set of vertices using `src/execute.py`.  The path is calculated via one of the solvers available at `src/solvers/*.py`.  Again, a user can integrate their own solver.  They'd do this by writting the code and putting it in the `src/solvers` folder and enabling it in the "USAGE" section of the document string at the top of `src/execute.py`.  The included solvers are:
    1.  `brute`: calculate the cost of all possible paths through a set and return the minimum cost path.  This is the only surefire way to get the optimal path but is incredably slow when N is large.
    1.  `nearestneighbor`: algorithm that, when at any given vertex, travels to the next closest vertex
    1.  `randomneighbor`: when at any given vertex, randomly selects another unvisited vertex to travel to next.  Expect this to be far form the optimal pathh through the city list. Do not return home to origin city after visiting every city.

Notes
Some important notes:
1.  Solutions visit all vertices
1.  The first vertex in the cityLocations file is considered the origin.  This is unchangeable.
1.  From any vertex one can visit any other vertex as long as they assume the cost in the cost matrix
    1.  This is important because in some Traveling Salesmen Problems, not every vertex can visit each other vertex.  We can account for this case by setting the cost of this path and its inverse (A->B has inverse B->A) to infinity in the cost matrix.  By doing this we introduce the subcase where a set of vertices may be intrinsicly unable to travel to another set of vertices, resulting in the cost of the lowest cost path equal to infinity.
1.  Once a path from A->B is taken, it and its inverse is removed from possible future paths to be taken.  AKA no repeats.
    1.  To explain, consider set {A, B, C, D}.  The path A->B->C->D is obvious, but the above statement disallows A->B->C->B->A->D.  If we considered paths like this I believe there would huge, but finitely many paths to consider on a set of finite size.  


Want To Contribute?
The goal of this project is to create an infrastructure for estimating solutions of the problem.  The infrastructure should:
- allow for a user to easily create an randomly generated vertex map:
    - using premade algorithums
    - by creating their own map creation algorithm
- allow for a user to easily apply a solution estimation algorithm to a vertex map:
    - using premade algorithms
    - by creating their own solution algorithm
- visualize solutions to previously executed solution algorithms
- easily apply various solution algorithms to maps created from various map creation algorithms
  
  
To Do:
1.  Make a "--demo" flag that a user can run immediatly upon cloning repo in order to get an idea for what this codebase can do
1.  Automated test cases so when building a feature we can tell what fails and what passes.
1.  Clear up why JSON is saved the way it is.  Fix save method such that non serilizable objects (2+ dimenionsal arrays) play nice with JSON format requirements.
    1.  Update: curretly using `toList()` to make 2D arrays serializable.
1.  Add functionality to define an origin vertex and to define the ability to have to end at that origin vertex.
1.  Redo CLI.
1.  Use YAML...
1.  Can stoichastic branches help?
1.  What about a ML algorithm?
1.  Be able to easily create statistics using a `wrapper.py` like program about how different algorithms work on different types of maps.
1.  What about cases where the distance Matrix changes over time?
1.  Decide if distance matrix can be used to fully power algs working on a set of vertices.  Do the algs need the actual city locations too?



\section*{Literature Cited}
%\end{multicols}

\end{document}




